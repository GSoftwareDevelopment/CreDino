; ------------------------------------------------------------
; Mad Pascal Compiler version 1.7.2 [2025/04/26] for MOS 6502 CPU
; ------------------------------------------------------------

STACKWIDTH	= 16
CODEORIGIN	= $2000

TRUE		= 1
FALSE		= 0
EOL		= $9B
__BUFFER	= $0400
@BUF		= __BUFFER

; ------------------------------------------------------------

	org $80

zpage

.if .def(@vbxe_detect)
fxptr	.ds 2						; VBXE pointer
.fi

.if .def(@AllocMem)||.def(MAIN.SYSTEM.GETMEM)||.def(MAIN.SYSTEM.FREEMEM)
psptr	.ds 2						; PROGRAMSTACK Pointer
.fi

bp	.ds 2
bp2	.ds 2
bp3	= bp+1

eax	.ds 4						;8 bytes (aex + edx) -> divREAL
edx	.ds 4
ecx	.ds 4

TMP
ztmp
ztmp8	.ds 1
ztmp9	.ds 1
ztmp10	.ds 1
ztmp11	.ds 1

STACKORIGIN	.ds STACKWIDTH*4
zpend

; ------------------------------------------------------------

ax	= eax
al	= eax
ah	= eax+1

cx	= ecx
cl	= ecx
ch	= ecx+1

dx	= edx
dl	= edx
dh	= edx+1

	org eax

FP1MAN0	.ds 1
FP1MAN1	.ds 1
FP1MAN2	.ds 1
FP1MAN3	.ds 1

	org edx

FP2MAN0	.ds 1
FP2MAN1	.ds 1
FP2MAN2	.ds 1
FP2MAN3	.ds 1

	org ecx

FPMAN0	.ds 1
FPMAN1	.ds 1
FPMAN2	.ds 1
FPMAN3	.ds 1

	org ztmp8

FP1SGN	.ds 1
FP1EXP	.ds 1

	org ztmp10

FP2SGN	.ds 1
FP2EXP	.ds 1

	org bp2

FPSGN	.ds 1
FPEXP	.ds 1

	.ifdef MAIN.@DEFINES.BASICOFF
	org CODEORIGIN
	icl 'atari\basicoff.asm'
	ini CODEORIGIN
	.fi

	.ifdef MAIN.@DEFINES.S_VBXE
	opt h-
	ins 'atari\s_vbxe\sdxld2.obx'
	opt h+
	.fi

	org CODEORIGIN

.local	MAIN.@RESOURCE
.endl

.local	RESOURCE
	icl 'atari\resource.asm'
	?EXTDETECT = 0
	?VBXDETECT = 0

	RMTPLAY 'music.feat' RMT_PLAYER 0 0 0 0 0 0 0 0
	RCDATA 'assets/title.fnt' FNT_TITLE 0 0 0 0 0 0 0 0
	RCDATA 'assets/title.scr' SCR_TITLE 0 0 0 0 0 0 0 0
	RCDATA 'assets/status.fnt' FNT_STATUS 0 0 0 0 0 0 0 0
	RCDATA 'assets/status.dat' STATUS_ADDR 0 0 0 0 0 0 0 0
	RCDATA 'assets/game.fnt' FNT_GAME 0 0 0 0 0 0 0 0
	RCDATA 'assets/gameover.dat' GOVER_ADDR 0 0 0 0 0 0 0 0
	RCDATA 'assets/crater.dat' CRATER_ADDR 0 0 0 0 0 0 0 0
	RCASM 'assets/sprites.a65' SPR_ADDR 0 0 0 0 0 0 0 0
	RCASM 'dl_title.a65' DL_TITLE 0 0 0 0 0 0 0 0
	RCASM 'dl_game.a65' DL_GAME 0 0 0 0 0 0 0 0
	RMT 'assets/music.rmt' RMT_MODUL 0 0 0 0 0 0 0 0
.endl

; ------------------------------------------------------------

	org CODEORIGIN

	STATICDATA

; ------------------------------------------------------------

RTLIB
	icl 'rtl6502_a8.asm'

.print 'ZPAGE: ',zpage,'..',zpend-1

.print 'RTBUF: ',@buf,'..',@buf+255

.print 'RTLIB: ',RTLIB,'..',*-1

; ------------------------------------------------------------

START
	tsx
	stx MAIN.@halt+1

	.ifdef MAIN.@DEFINES.ROMOFF
	icl 'atari\romoff.asm'
	.fi

VLEN	= VARDATASIZE-VARINITSIZE
VADR	= DATAORIGIN+VARINITSIZE

	ift (VADR > $BFFF) && .not(.def MAIN.@DEFINES.ROMOFF)
	ert 'Invalid memory address range ',VADR
	eif

	ift (VLEN > 0) && (VLEN <= 256)
	ldx #256-VLEN
	lda #$00
	sta:rne VADR+VLEN-256,x+
	eli VLEN>256
	m@init
	eif

.ifdef psptr
	mwa #PROGRAMSTACK psptr
.fi

	ldx #$00					; X = 0
	stx bp						; BP = 0

	stx audctl					; reset POKEY
	stx audctl+$10
	lda #3
	sta skctl
	sta skctl+$10

	dex						; X = 255

	UNITINITIALIZATION

.local	MAIN						; PROCEDURE

	jmp l_0004

; ------------------------------------------------------------

.local	SYSTEM						; UNIT

.local	PEEK						; FUNCTION | ASSEMBLER | REGISTER

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta A
	lda :STACKORIGIN+STACKWIDTH,x
	sta A+1
	dex
@main

; -------------------  ASM Block 00000002  -------------------

	ldy #0
	mva (:edx),y Result

@exit

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif

; ------------------------------------------------------------

A	= :EDX
RESULT	= :STACKORIGIN-4

	rts						; ret
.endl

.local	POKE						; PROCEDURE | ASSEMBLER | REGISTER

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta A
	lda :STACKORIGIN+STACKWIDTH,x
	sta A+1
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	lda :STACKORIGIN,x
	sta VALUE
	dex
@main

; -------------------  ASM Block 00000025  -------------------

	ldy #0
	mva value (:edx),y

; ------------------------------------------------------------

A	= :EDX
VALUE	= :ECX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	DPOKE						; PROCEDURE | ASSEMBLER | REGISTER

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta A
	lda :STACKORIGIN+STACKWIDTH,x
	sta A+1
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta VALUE
	lda :STACKORIGIN+STACKWIDTH,x
	sta VALUE+1
	dex
@main

; -------------------  ASM Block 00000026  -------------------

	ldy #0
	mva value (:edx),y
	iny
	mva value+1 (:edx),y

; ------------------------------------------------------------

A	= :EDX
VALUE	= :ECX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	FILLCHAR					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER | INLINE
.local	@03018000001810000188000

	.MACRO m@INLINE

; -------------------  ASM Block 00000028  -------------------

	jsr @fill

	.ENDM

; ------------------------------------------------------------

A	= :EDX
COUNT	= :ECX
VALUE	= :EAX

@exit
.endl
.endl							; overload

.local	RANDOM						; FUNCTION | ASSEMBLER | OVERLOAD
.local	@010180000
	sta RANGE

; -------------------  ASM Block 00000049  -------------------


;BYTE FUNC Rand(BYTE range)
; returns random number between 0 and
; range-1.  If range=0, then a random
; number between 0 and 255 is returned

  ldy $d20a   ; RANDOM

  lda range
  beq stop

  sta :ecx
  sty :eax

  jsr imulCL
  tay

stop  sty Result


@exit

; ------------------------------------------------------------

RANGE	= DATAORIGIN+$000B
RESULT	= DATAORIGIN+$000C

@VarData	= RANGE
@VarDataSize	= 1

	rts						; ret
.endl
.endl							; overload

; ------------------------------------------------------------
; ------------------------------------------------------------
@UnitInit

; -------------------  ASM Block 00000060  -------------------

	.ifdef @CmdLine

	ldx #$0F
	mva:rpl $340,x IOCB@COPY,x-
	rts

IOCB@COPY	:16 brk
	eif


	rts

; ------------------------------------------------------------

M_PI_2	= $0648
D_PI_2	= $0192
D_PI_180	= $04
__PORTB_BANKS	= $0101
MGTIA	= $00
MVBXE	= $80
VBXE_XDLADR	= $00
VBXE_BCBTMP	= $E0
VBXE_BCBADR	= $0100
VBXE_MAPADR	= $1000
VBXE_CHBASE	= $1000
VBXE_OVRADR	= $5000
VBXE_WINDOW	= $B000
IDLI	= $00
IVBL	= $01
IVBLD	= $01
IVBLI	= $02
ITIM1	= $03
ITIM2	= $04
ITIM4	= $05
CH_DELCHR	= $FE
CH_ENTER	= $9B
CH_ESC	= $1B
CH_CURS_UP	= $1C
CH_CURS_DOWN	= $1D
CH_CURS_LEFT	= $1E
CH_CURS_RIGHT	= $1F
CH_TAB	= $7F
CH_EOL	= $9B
CH_CLR	= $7D
CH_BELL	= $FD
CH_DEL	= $7E
CH_DELLINE	= $9C
CH_INSLINE	= $9D
PAL_PMCOLOR0	= $00
PAL_PMCOLOR1	= $01
PAL_PMCOLOR2	= $02
PAL_PMCOLOR3	= $03
PAL_COLOR0	= $04
PAL_COLOR1	= $05
PAL_COLOR2	= $06
PAL_COLOR3	= $07
PAL_COLBAK	= $08
COLOR_BLACK	= $00
COLOR_WHITE	= $0E
COLOR_RED	= $32
COLOR_CYAN	= $96
COLOR_VIOLET	= $68
COLOR_GREEN	= $C4
COLOR_BLUE	= $74
COLOR_YELLOW	= $EE
COLOR_ORANGE	= $28
COLOR_BROWN	= $E4
COLOR_LIGHTRED	= $3C
COLOR_GRAY1	= $04
COLOR_GRAY2	= $06
COLOR_GRAY3	= $0A
COLOR_LIGHTGREEN	= $CC
COLOR_LIGHTBLUE	= $7C
FMOPENREAD	= $04
FMOPENWRITE	= $08
FMOPENAPPEND	= $09
FMOPENREADWRITE	= $0C
DATESEPARATOR	= DATAORIGIN+$0000
RND	= $D20A
adr.PALETTE	= $02C0
.var PALETTE	= adr.PALETTE .word
adr.HPALETTE	= $D012
.var HPALETTE	= adr.HPALETTE .word
FILEMODE	= DATAORIGIN+$0001
GRAPHMODE	= DATAORIGIN+$0002
IORESULT	= DATAORIGIN+$0003
EOLN	= DATAORIGIN+$0004
SCREENWIDTH	= DATAORIGIN+$0005
SCREENHEIGHT	= DATAORIGIN+$0007
adr.MEM	= $00
.var MEM	= adr.MEM .word
RNDSEED	= DATAORIGIN+$0009

.endl							; UNIT SYSTEM

; ------------------------------------------------------------

.local	ATARI						; UNIT

; ------------------------------------------------------------

DL_BLANK1	= $00
DL_BLANK2	= $10
DL_BLANK3	= $20
DL_BLANK4	= $30
DL_BLANK5	= $40
DL_BLANK6	= $50
DL_BLANK7	= $60
DL_BLANK8	= $70
DL_DLI	= $80
DL_LMS	= $40
DL_VSCROLL	= $20
DL_HSCROLL	= $10
DL_JMP	= $01
DL_JVB	= $41
DL_MODE_GR15	= $0E
DL_MODE_GR8	= $0F
IRQENS	= $10
RTCLOK	= $12
RTCLOK1	= $12
RTCLOK2	= $13
RTCLOK3	= $14
ATRACT	= $4D
LMARGIN	= $52
RMARGIN	= $53
ROWCRS	= $54
COLCRS	= $55
DINDEX	= $57
SAVMSC	= $58
PALNTS	= $62
RAMTOP	= $6A
VDSLST	= $0200
SDLSTL	= $0230
TXTROW	= $0290
TXTCOL	= $0291
TINDEX	= $0293
TXTMSC	= $0294
SDMCTL	= $022F
GPRIOR	= $026F
CRSINH	= $02F0
CHACT	= $02F3
CHBAS	= $02F4
CH	= $02FC
FILDAT	= $02FD
PCOLR0	= $02C0
PCOLR1	= $02C1
PCOLR2	= $02C2
PCOLR3	= $02C3
COLOR0	= $02C4
COLOR1	= $02C5
COLOR2	= $02C6
COLOR3	= $02C7
COLOR4	= $02C8
COLBAKS	= $02C8
HPOSP0	= $D000
HPOSP1	= $D001
HPOSP2	= $D002
HPOSP3	= $D003
HPOSM0	= $D004
HPOSM1	= $D005
HPOSM2	= $D006
HPOSM3	= $D007
SIZEP0	= $D008
SIZEP1	= $D009
SIZEP2	= $D00A
SIZEP3	= $D00B
SIZEM	= $D00C
GRAFP0	= $D00D
GRAFP1	= $D00E
GRAFP2	= $D00F
GRAFP3	= $D010
GRAFM	= $D011
P0PF	= $D004
PAL	= $D014
TRIG3	= $D013
COLPM0	= $D012
COLPM1	= $D013
COLPM2	= $D014
COLPM3	= $D015
COLPF0	= $D016
COLPF1	= $D017
COLPF2	= $D018
COLPF3	= $D019
COLBAK	= $D01A
COLBK	= $D01A
PRIOR	= $D01B
GRACTL	= $D01D
PMCNTL	= $D01D
HITCLR	= $D01E
CONSOL	= $D01F
AUDF1	= $D200
AUDC1	= $D201
AUDF2	= $D202
AUDC2	= $D203
AUDF3	= $D204
AUDC3	= $D205
AUDF4	= $D206
AUDC4	= $D207
AUDCTL	= $D208
KBCODE	= $D209
IRQEN	= $D20E
SKSTAT	= $D20F
PORTA	= $D300
PORTB	= $D301
PACTL	= $D302
DMACTL	= $D400
CHACTL	= $D401
DLISTL	= $D402
HSCROL	= $D404
VSCROL	= $D405
PMBASE	= $D407
CHBASE	= $D409
WSYNC	= $D40A
VCOUNT	= $D40B
PENH	= $D40C
PENV	= $D40D
NMIEN	= $D40E
NMIVEC	= $FFFA
RESETVEC	= $FFFC
IRQVEC	= $FFFE

.endl							; UNIT ATARI

; ------------------------------------------------------------

.local	MISC						; UNIT

.local	DETECTANTIC					; FUNCTION | ASSEMBLER

; -------------------  ASM Block 00000061  -------------------


// ANTIC PAL Test for Atari 8-bits
// (C) 2019 Guillermo Fuenzalida

antic_loop1
	lda vcount
	cmp #100
	bcc antic_loop1		// wait till scanline 200
	sta scanline
antic_loop2
	lda vcount
	cmp #10
	bmi antic_loop2_fin
	cmp scanline
	bmi antic_loop2
	sta scanline
	bpl antic_loop2

antic_loop2_fin
	ldy #$00
	lda #0
scanline equ *-1
	cmp #135
	bmi ntsc
	iny
ntsc
	sty Result


@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$000D

	rts						; ret
.endl

; ------------------------------------------------------------

adr.BANKS	= $0101
.var BANKS	= adr.BANKS .word
DETECTOS	= $FFF7

.endl							; UNIT MISC

; ------------------------------------------------------------

.local	RMT						; UNIT

.local	TRMT.INIT					; PROCEDURE | ASSEMBLER
	sta TRMT
	sty TRMT+1
	sta PLAYER
	sty PLAYER+1
	add #2
	scc
	iny
	sta MODUL
	sty MODUL+1

; -------------------  ASM Block 00000071  -------------------

	txa:pha

	mwa TRMT :bp2

	ldy #1
	lda (:bp2),y
	sta adr+2

	iny
	lda (:bp2),y
	tax		; low byte of RMT module to X reg
	iny
	lda (:bp2),y
	tay		; hi byte of RMT module to Y reg

	lda a		; starting song line 0-255 to A reg
adr	jsr $ff03	; jsr player+3

	pla:tax

; ------------------------------------------------------------

TRMT	= DATAORIGIN+$000F
A	= DATAORIGIN+$0011
PLAYER	= DATAORIGIN+$0012
MODUL	= DATAORIGIN+$0014

@VarData	= TRMT
@VarDataSize	= 7

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TRMT.SFX					; PROCEDURE | ASSEMBLER
	sta TRMT
	sty TRMT+1
	sta PLAYER
	sty PLAYER+1
	add #2
	scc
	iny
	sta MODUL
	sty MODUL+1

; -------------------  ASM Block 00000072  -------------------

	txa:pha

	mwa TRMT adr+1

	ldy #1
adr	lda $ffff,y
	sta ptr+2

	lda effect
	asl @
	tay

	ldx channel
	lda note

ptr	jsr $ff0f	; jsr player+15

	pla:tax

; ------------------------------------------------------------

TRMT	= DATAORIGIN+$0016
EFFECT	= DATAORIGIN+$0018
CHANNEL	= DATAORIGIN+$0019
NOTE	= DATAORIGIN+$001A
PLAYER	= DATAORIGIN+$001B
MODUL	= DATAORIGIN+$001D

@VarData	= TRMT
@VarDataSize	= 9

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TRMT.PLAY					; PROCEDURE | ASSEMBLER
	sta TRMT
	sty TRMT+1
	sta PLAYER
	sty PLAYER+1
	add #2
	scc
	iny
	sta MODUL
	sty MODUL+1

; -------------------  ASM Block 00000073  -------------------

	txa:pha

	asl ntsc		; =0 PAL, =4 NTSC
	bcc skp

	lda #%00000100
	sta ntsc

	bne quit
skp
	mwa TRMT adr+1

	ldy #1
adr	lda $ffff,y
	sta ptr+2

ptr	jsr $ff00		; jmp (TRMT)	6502 buggy indirect jump

quit	pla:tax

; ------------------------------------------------------------

TRMT	= DATAORIGIN+$001F
PLAYER	= DATAORIGIN+$0021
MODUL	= DATAORIGIN+$0023

@VarData	= TRMT
@VarDataSize	= 6

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------
; ------------------------------------------------------------
@UnitInit

; optimize FAIL ('MISC.DETECTANTIC', RMT), line = 159

	jsr MISC.DETECTANTIC
	lda MISC.DETECTANTIC.RESULT
	jeq l_00A6

; optimize OK (RMT), line = 160

	lda #$00
	jmp l_00B4
l_00A6

; optimize OK (RMT), line = 162

	lda #$04
l_00B4
	sta NTSC

	rts

; ------------------------------------------------------------

NTSC	= DATAORIGIN+$000E

.endl							; UNIT RMT

.local	WAIT4SCREEN					; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000075  -------------------

  lda $d40b
  bne *-3
  lda $d40b
  beq *-3

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PLAYSFX						; PROCEDURE
	sta NSFX

; optimize OK (game_helpers.pas), line = 13

	cmp #$15
	jne l_00CE

; optimize OK (game_helpers.pas), line = 14

	sta RMT.TRMT.SFX.EFFECT
	lda #$02
	sta RMT.TRMT.SFX.CHANNEL
	lda #$01
	jmp l_00DE
l_00CE

; optimize OK (game_helpers.pas), line = 16

	lda NSFX
	sta RMT.TRMT.SFX.EFFECT
	lda #$03
	sta RMT.TRMT.SFX.CHANNEL
	lda #$20
l_00DE
	sta RMT.TRMT.SFX.NOTE
	lda MSX
	ldy MSX+1
	jsr RMT.TRMT.SFX

; ------------------------------------------------------------

NSFX	= DATAORIGIN+$002E

@VarData	= NSFX
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TURNOFF						; PROCEDURE

; optimize FAIL ('WAIT4SCREEN', game_helpers.pas), line = 72

	jsr WAIT4SCREEN

; optimize OK (game_helpers.pas), line = 73

	lda #$00
	sta ATARI.SDMCTL

; optimize FAIL ('WAIT4SCREEN', game_helpers.pas), line = 74

	jsr WAIT4SCREEN

; optimize OK (game_helpers.pas), line = 75

	lda #$00
	sta IRQST

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TURNON						; PROCEDURE

; optimize OK (game_helpers.pas), line = 80

	lda VBL+1
	ora VBL
	jeq l_0107

; optimize OK (game_helpers.pas), line = 81

	lda VBL
	ldy #5
	sta wsync
	dey
	rne
	sta VVBLKD
	lda VBL+1
	sta VVBLKD+1
l_0107

; optimize OK (game_helpers.pas), line = 82

	lda DLI+1
	ora DLI
	jeq l_011D

; optimize OK (game_helpers.pas), line = 83

	mva DLI VDSLST
	mva DLI+1 VDSLST+1
l_011D

; optimize OK (game_helpers.pas), line = 84

	lda #$C0
	sta IRQST

; optimize FAIL ('WAIT4SCREEN', game_helpers.pas), line = 86

	jsr WAIT4SCREEN

; optimize OK (game_helpers.pas), line = 87

	lda DMACTL
	sta ATARI.SDMCTL

; ------------------------------------------------------------

VBL	= DATAORIGIN+$002F
DLI	= DATAORIGIN+$0031
DMACTL	= DATAORIGIN+$0033

@VarData	= VBL
@VarDataSize	= 5

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PUTDINO						; PROCEDURE

; optimize OK (pmg.pas), line = 46

	lda DINOX
	cmp #$30
	jcs l_0143
	lda #$30
	sta DINOX
l_0143

; optimize OK (pmg.pas), line = 47

	lda DINOX
	cmp #$D5
	jcc l_015C
	lda #$D4
	sta DINOX
l_015C

; optimize OK (pmg.pas), line = 48

	lda DINOX
	sta adr.HPOSP

; optimize OK (pmg.pas), line = 49

	sta adr.HPOSP+$01

; optimize OK (pmg.pas), line = 50

	lda ODINOY
	cmp DINOY
	jeq l_0185

; optimize OK (pmg.pas), line = 52

	lda DINOY
	cmp #$40
	jcs l_0198
	lda #$40
	sta DINOY
l_0198

; optimize OK (pmg.pas), line = 53

	lda DINOY
	cmp #$B9
	jcc l_01B1
	lda #$B8
	sta DINOY
l_01B1

; optimize OK (pmg.pas), line = 54

	lda DINOY
	cmp ODINOY
	jcs l_01CC

; optimize OK (pmg.pas), line = 56

	lda ODINOY
	sub DINOY
	sta DY
	sub #$11
	svc
	eor #$80
	jmi l_01EB
	lda #$10
	sta DY
l_01EB

; optimize OK (pmg.pas), line = 57

	lda ODINOY
	add #$10
	sub DY
	jmp l_020B
l_01CC

; optimize OK (pmg.pas), line = 61

	lda DINOY
	sub ODINOY
	sta DY
	sub #$11
	svc
	eor #$80
	jmi l_0229
	lda #$10
	sta DY
l_0229

; optimize OK (pmg.pas), line = 62

	lda ODINOY
l_020B
	sta Z

; optimize OK (pmg.pas), line = 64

	jeq l_0248

; -------------------  ASM Block 00000077  -------------------

        txa:pha
        ldy z
        ldx dy
        lda #0
      lzero:
        sta adr._PL0,y
        sta adr._PL1,y
        iny
        dex
        bpl lzero
        pla:tax
      
l_0248
	jmp l_0254
l_0185

; optimize OK (pmg.pas), line = 82

	lda #$00
	sta Z
l_0254

; optimize OK (pmg.pas), line = 83

	lda DINOFRM
	cmp ODINOFRM
	jne l_027Ax
	lda ODINOY
	cmp DINOY
	jeq l_027A
l_027Ax

; -------------------  ASM Block 00000078  -------------------

      txa:pha
      lda DINOFrm
      asl @
      tax

      lda adr.DINOP0,x
      sta ptr1
      lda adr.DINOP0+1,x
      sta ptr1+1

      lda adr.DINOP1,x
      sta ptr2
      lda adr.DINOP1+1,x
      sta ptr2+1

      ldy #0
      ldx DINOY
    ldraw:
      lda (ptr1),y
      sta adr._PL0,x
      lda (ptr2),y
      sta adr._PL1,x
      inx
      iny
      cpy #16
      bne ldraw
      pla:tax
    
; optimize OK (pmg.pas), line = 115

	lda DINOFRM
	sta ODINOFRM

; optimize OK (pmg.pas), line = 116

	lda DINOY
	sta ODINOY
l_027A

; ------------------------------------------------------------

DY	= DATAORIGIN+$0042
Z	= DATAORIGIN+$0043

@VarData	= DY
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PUTSTONE					; PROCEDURE

; optimize OK (pmg.pas), line = 126

	lda STONEX
	sta adr.HPOSP+$02

; optimize OK (pmg.pas), line = 127

	lda OSTONEY
	cmp STONEY
	jeq l_02A8

; optimize OK (pmg.pas), line = 129

	lda STONEY
	cmp #$FF
	jne l_02BB

; -------------------  ASM Block 00000079  -------------------

        txa:pha
        ldy oSTONEY
        ldx #16
        lda #0
      lzero1:
        sta adr._PL2,y
        iny
        dex
        bpl lzero1
        pla:tax
      
	jmp @exit
l_02BB

; optimize OK (pmg.pas), line = 147

	lda STONEY
	cmp #$20
	jcs l_02D7
	lda #$20
	sta STONEY
l_02D7

; optimize OK (pmg.pas), line = 148

	lda STONEY
	cmp #$B9
	jcc l_02F0
	lda #$B8
	sta STONEY
l_02F0
l_02C5

; optimize OK (pmg.pas), line = 150

	lda STONEY
	cmp OSTONEY
	jcs l_030B

; optimize OK (pmg.pas), line = 152

	lda OSTONEY
	sub STONEY
	sta DY
	sub #$11
	svc
	eor #$80
	jmi l_032A
	lda #$10
	sta DY
l_032A

; optimize OK (pmg.pas), line = 153

	lda OSTONEY
	add #$10
	sub DY
	jmp l_034A
l_030B

; optimize OK (pmg.pas), line = 157

	lda STONEY
	sub OSTONEY
	sta DY
	sub #$11
	svc
	eor #$80
	jmi l_0368
	lda #$10
	sta DY
l_0368

; optimize OK (pmg.pas), line = 158

	lda OSTONEY
l_034A
	sta Z

; optimize OK (pmg.pas), line = 160

	jeq l_0387

; -------------------  ASM Block 00000080  -------------------

        txa:pha
        ldy z
        ldx dy
        lda #0
      lzero:
        sta adr._PL2,y
        iny
        dex
        bpl lzero
        pla:tax
      
l_0387
	jmp l_0393
l_02A8

; optimize OK (pmg.pas), line = 177

	lda #$00
	sta Z
l_0393

; optimize OK (pmg.pas), line = 178

	lda STONEFRM
	cmp OSTONEFRM
	jne l_03B9x
	lda OSTONEY
	cmp STONEY
	jeq l_03B9
l_03B9x

; -------------------  ASM Block 00000081  -------------------

      txa:pha
      lda STONEFrm
      asl @
      tax

      lda adr.STONEP2,x
      sta ptr1
      lda adr.STONEP2+1,x
      sta ptr1+1

      ldy #0
      ldx STONEY
    ldraw:
      lda (ptr1),y
      sta adr._PL2,x
      inx
      iny
      cpy #16
      bne ldraw
      pla:tax
    
; optimize OK (pmg.pas), line = 202

	lda STONEFRM
	sta OSTONEFRM

; optimize OK (pmg.pas), line = 203

	lda STONEY
	sta OSTONEY
l_03B9

; ------------------------------------------------------------

DY	= DATAORIGIN+$0044
Z	= DATAORIGIN+$0045

@VarData	= DY
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PMGCLEAR					; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000082  -------------------

    ldy #0
    lda #0
  lzero:
    sta adr._PL0,y
    sta adr._PL1,y
    dey
    bne lzero

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	VBL_TITLE_SCREEN				; PROCEDURE | INTERRUPT

; -------------------  ASM Block 00000083  -------------------

    xitvbl      = $e462
    sysvbv      = $e45c
    portb       = $d301

      phr

      ldx #6
  tmLoop:
      lda adr.timer,x
      beq tmNext
      dec adr.timer,x
  tmNext:
      dex
      bpl tmLoop
  
; -------------------  ASM Block 00000084  -------------------

    dec PORTB
  
; optimize FAIL ('RMT.TRMT.PLAY', title_vbl.pas), line = 23

	lda MSX
	ldy MSX+1
	jsr RMT.TRMT.PLAY

; -------------------  ASM Block 00000085  -------------------

    inc PORTB
  
; -------------------  ASM Block 00000086  -------------------

      plr
      jmp xitvbl
  
	rti						; ret
.endl

.local	DLI_TITLE_SCREEN				; PROCEDURE | ASSEMBLER | INTERRUPT

; -------------------  ASM Block 00000087  -------------------

  _regA = $6D;
  _regX = $6E;
  _regY = $6F;

dli0:
  sta _regA
  stx _regX

  lda #$94
  sta WSYNC
  sta chbase

  lda #<DLI1
  ldx #>DLI1
  sta VDSLST
  stx VDSLST+1

  lda _regA
  ldx _regX
  rti

dli1:
  sta _regA
  stx _regX

  lda #$90
  sta WSYNC
  sta chbase

  lda #<DLI2
  ldx #>DLI2
  sta VDSLST
  stx VDSLST+1

  lda _regA
  ldx _regX
  rti

dli2:
  sta _regA
  stx _regX

  lda #$94
  sta WSYNC
  sta chbase

  lda #<DLI3
  ldx #>DLI3
  sta VDSLST
  stx VDSLST+1

  lda _regA
  ldx _regX
  rti

dli3:
  sta _regA
  stx _regX

  lda #$90
  sta WSYNC
  sta chbase

  lda #<DLI4
  ldx #>DLI4
  sta VDSLST
  stx VDSLST+1

  lda _regA
  ldx _regX
  rti

dli4:
  sta _regA
  stx _regX

  lda #$94
  sta WSYNC
  sta chbase

  lda #<DLI5
  ldx #>DLI5
  sta VDSLST
  stx VDSLST+1

  lda _regA
  ldx _regX
  rti

dli5:
  sta _regA
  stx _regX

  lda #$90
  sta WSYNC
  sta chbase

  lda #<DLI0
  ldx #>DLI0
  sta VDSLST
  stx VDSLST+1

  lda _regA
  ldx _regX
  rti


	rti						; ret
.endl

.local	INIT_TITLE					; PROCEDURE

; optimize FAIL ('TURNOFF', title.pas), line = 6

	jsr TURNOFF

; optimize OK (title.pas), line = 7

	lda #$90
	sta DL
	lda #$BF
	sta DL+1

; optimize OK (title.pas), line = 8

	lda #$90
	sta CHBAS

; optimize OK (title.pas), line = 10

	lda #$00
	sta adr.FCOL
	lda #$16
	sta adr.FCOL+$01
	lda #$1E
	sta adr.FCOL+$02
	sta adr.FCOL+$03
	lda #$00
	sta adr.FCOL+$04

; optimize OK (title.pas), line = 11

	lda #$04
	sta adr.PCOLR
	lda #$CA
	sta adr.PCOLR+$01

; optimize FAIL ('PMGCLEAR', title.pas), line = 13

	jsr PMGCLEAR

; optimize OK (title.pas), line = 15

	lda <VBL_TITLE_SCREEN
	sta TURNON.VBL
	lda >VBL_TITLE_SCREEN
	sta TURNON.VBL+1
	lda <DLI_TITLE_SCREEN
	sta TURNON.DLI
	lda >DLI_TITLE_SCREEN
	sta TURNON.DLI+1
	lda #$3F
	sta TURNON.DMACTL
	jsr TURNON

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TITLE_LOOP					; PROCEDURE

; optimize OK (title.pas), line = 20

	lda #$00
	sta RMT.TRMT.INIT.A
	lda MSX
	ldy MSX+1
	jsr RMT.TRMT.INIT

; --- RepeatUntilProlog
l_0409

; optimize OK (title.pas), line = 23

	lda ATARI.CONSOL
	cmp #$06
	jeq l_0409x
	lda adr.STRIG
	jne l_0409
l_0409x

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	VBL_GAME_SCREEN					; PROCEDURE | INTERRUPT

; -------------------  ASM Block 00000088  -------------------

    xitvbl      = $e462
    sysvbv      = $e45c
    portb       = $d301

      phr

;      lda #<MAIN.DLI_GAME_SCREEN.START
;      ldx #>MAIN.DLI_GAME_SCREEN.START
;      sta VDSLST
;      stx VDSLST+1


      ldx #6
  tmLoop:
      lda adr.timer,x
      beq tmNext
      dec adr.timer,x
  tmNext:
      dex
      bpl tmLoop
  
; optimize OK (game_vbl.pas), line = 42

	lda GAMESTATE
	cmp #$03
	jcs l_0436

; optimize FAIL ('PUTDINO', game_vbl.pas), line = 44

	jsr PUTDINO

; optimize FAIL ('PUTSTONE', game_vbl.pas), line = 45

	jsr PUTSTONE
l_0436

; -------------------  ASM Block 00000089  -------------------

    dec PORTB
  
; optimize FAIL ('RMT.TRMT.PLAY', game_vbl.pas), line = 55

	lda MSX
	ldy MSX+1
	jsr RMT.TRMT.PLAY

; -------------------  ASM Block 00000090  -------------------

    inc PORTB
  
; -------------------  ASM Block 00000091  -------------------

      plr
      jmp xitvbl
  
	rti						; ret
.endl

.local	DLI_GAME_SCREEN					; PROCEDURE | ASSEMBLER | INTERRUPT

; -------------------  ASM Block 00000092  -------------------

  _regA = $6D;
  _regX = $6E;
  _regY = $6F;

SKY0:
  sta _regA
  stx _regX

  lda #$82
  sta WSYNC
  sta COLPF4

  lda #<SKY1
  ldx #>SKY1
  sta VDSLST
  stx VDSLST+1

  lda _regA
  ldx _regX
  rti

SKY1:
  sta _regA
  stx _regX

  lda #$84
  sta WSYNC
  sta COLPF4

  lda #<SKY2
  ldx #>SKY2
  sta VDSLST
  stx VDSLST+1

  lda _regA
  ldx _regX
  rti

SKY2:
  sta _regA
  stx _regX

  lda #$86
  sta WSYNC
  sta COLPF4

  lda #<SKY3
  ldx #>SKY3
  sta VDSLST
  stx VDSLST+1

  lda _regA
  ldx _regX
  rti

SKY3:
  sta _regA
  stx _regX

  lda #$88
  sta WSYNC
  sta COLPF4

  lda #<SKY4
  ldx #>SKY4
  sta VDSLST
  stx VDSLST+1

  lda _regA
  ldx _regX
  rti

SKY4:
  sta _regA
  stx _regX

  lda #$8a
  sta WSYNC
  sta COLPF4

  lda #<GND0
  ldx #>GND0
  sta VDSLST
  stx VDSLST+1

  lda _regA
  ldx _regX
  rti

GND0:
  sta _regA
  stx _regX

  lda #$16
  sta WSYNC
  sta COLPF4

  lda #<STS0
  ldx #>STS0
  sta VDSLST
  stx VDSLST+1

  lda _regA
  ldx _regX
  rti

STS0:
  sta _regA
  stx _regX

  lda >FNT_STATUS
  sta WSYNC
  sta chbase
  lda #$c6
  sta COLPF1

  lda #<SKY0
  ldx #>SKY0
  sta VDSLST
  stx VDSLST+1

  lda _regA
  ldx _regX
  rti

	rti						; ret
.endl

.local	PREPARE_STAGE					; PROCEDURE

; optimize OK (game.pas), line = 102

	lda #$00
	m@fill $B800 8

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	INIT_GAME					; PROCEDURE

; optimize FAIL ('TURNOFF', game.pas), line = 107

	jsr TURNOFF

; optimize OK (game.pas), line = 108

	lda #$D0
	sta DL
	lda #$BF
	sta DL+1

; optimize OK (game.pas), line = 109

	lda #$AC
	sta CHBAS

; optimize OK (game.pas), line = 111

	lda #$D0
	sta $BFDF
	lda #$B8
	sta $BFDF+1

; optimize OK (game.pas), line = 113

	lda #$00
	sta adr.FCOL
	lda #$16
	sta adr.FCOL+$01
	lda #$1E
	sta adr.FCOL+$02
	lda #$0F
	sta adr.FCOL+$03
	lda #$00
	sta adr.FCOL+$04

; optimize OK (game.pas), line = 114

	lda #$04
	sta adr.PCOLR
	lda #$CA
	sta adr.PCOLR+$01

; optimize FAIL ('PMGCLEAR', game.pas), line = 116

	jsr PMGCLEAR

; optimize FAIL ('PREPARE_STAGE', game.pas), line = 118

	jsr PREPARE_STAGE

; optimize OK (game.pas), line = 119

	lda #$00
	sta $BFF1
	lda #$A8
	sta $BFF1+1

; optimize OK (game.pas), line = 121

	lda <VBL_GAME_SCREEN
	sta TURNON.VBL
	lda >VBL_GAME_SCREEN
	sta TURNON.VBL+1
	lda <DLI_GAME_SCREEN
	sta TURNON.DLI
	lda >DLI_GAME_SCREEN
	sta TURNON.DLI+1
	lda #$3E
	sta TURNON.DMACTL
	jsr TURNON

; optimize OK (game.pas), line = 123

	lda #$22
	sta GPRIO

; optimize OK (game.pas), line = 124

	lda #$B0
	sta PMBASE

; optimize OK (game.pas), line = 125

	lda #$03
	sta PMCNTL

; optimize OK (game.pas), line = 127

	lda #$80
	sta DINOX

; optimize OK (game.pas), line = 128

	sta DINOY

; optimize OK (game.pas), line = 129

	lda #$00
	sta DINOFRM

; optimize OK (game.pas), line = 130

	lda #$80
	sta DINOSTATE

; optimize OK (game.pas), line = 132

	lda #$FF
	sta PTEROSTATE

; optimize FAIL (2, game.pas), line = 133

	inx
	mva #$02 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$C8 :STACKORIGIN,x
	lda #$19
	jsr SYSTEM.RANDOM.@010180000
	lda :STACKORIGIN,x
	add SYSTEM.RANDOM.@010180000.RESULT
	ldy :STACKORIGIN-1,x
	sta adr.TIMER,y
	dex
	dex

; optimize OK (game.pas), line = 134

	lda #$FF
	sta STONESTATE

; optimize OK (game.pas), line = 135

	lda #$00
	sta STONEDST

; optimize OK (game.pas), line = 137

	lda #$01
	sta GAMESTATE

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	DINOANIM					; PROCEDURE | INLINE

	.MACRO m@INLINE

; optimize OK (game.pas), line = 163

	lda DINOSTATE
	ldy #1
	and #$80
	beq @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda DINODX
	beq @+
	dey
@
	sty :STACKORIGIN+10
	ldy #1
	lda DINODY
	beq @+
	dey
@
	tya
	and :STACKORIGIN+10
	and :STACKORIGIN+9
	jeq l_04E7

; optimize OK (game.pas), line = 165

	lda DINOSTATE
	ora #$80
	sta DINOSTATE

; optimize OK (game.pas), line = 166

	lda DINOFRM
	and #$02
	sta DINOFRM
l_04E7

; optimize OK (game.pas), line = 169

	lda DINOSTATE
	jmi l_0514

; optimize OK (game.pas), line = 171

	lda adr.TIMER
	jne l_0528

; optimize OK (game.pas), line = 173

	lda #$03
	sta adr.TIMER

; optimize OK (game.pas), line = 174

	lda DINOSTATE
	and #$10
	jne l_0544

; optimize OK (game.pas), line = 175

	lda DINOSTATE
	and #$06
	sta :STACKORIGIN+9
	lda DINOFRM
	and #$01
	eor #$01
	ora :STACKORIGIN+9
	sta DINOFRM
l_0544

; optimize OK (game.pas), line = 177

	lda DINODX
	jeq l_0571

; optimize OK (game.pas), line = 179

	lda DINOX
	add DINODX
	sta DINOX

; optimize OK (game.pas), line = 180

	lda DINODX
	jmi l_0587
	jeq l_0587

; optimize FAIL (0, game.pas), line = 181

	dec DINODX
	jmp l_0595
l_0587

; optimize FAIL (0, game.pas), line = 183

	inc DINODX
l_0595

; optimize OK (game.pas), line = 184

	lda DINOSTATE
	and #$18
	jne l_05AF

; optimize OK (game.pas), line = 185

	lda #$14
	jsr PLAYSFX
l_05AF
l_0571

; optimize OK (game.pas), line = 188

	lda DINOSTATE
	and #$08
	jne l_05CC

; optimize OK (game.pas), line = 190

	lda DINOSTATE
	and #$10
	jne l_05E3

; optimize OK (game.pas), line = 192

	lda DINODY
	jeq l_05F6

; optimize OK (game.pas), line = 194

	lda DINOY
	add DINODY
	sta DINOY

; optimize OK (game.pas), line = 195

	lda DINODY
	jmi l_060C
	jeq l_060C

; optimize FAIL (0, game.pas), line = 196

	dec DINODY
	jmp l_061A
l_060C

; optimize FAIL (0, game.pas), line = 198

	inc DINODY
l_061A

; optimize OK (game.pas), line = 199

	lda GAMESTATE
	cmp #$01
	jne l_0630

; optimize OK (game.pas), line = 200

	lda #$14
	jsr PLAYSFX
l_0630
l_05F6
	jmp l_0640
l_05E3

; optimize OK (game.pas), line = 205

	lda DINODY
	jpl l_0652

; optimize OK (game.pas), line = 207

	lda DINOY
	add DINODY
	sta DINOY

; optimize FAIL (0, game.pas), line = 208

	inc DINODY

; optimize OK (game.pas), line = 209

	cmp #$40
	jne l_066C

; optimize OK (game.pas), line = 211

	lda #$01
	sta GAMESTATE

; optimize OK (game.pas), line = 212

	lda #$D0
	sta $BFDF
	lda #$B8
	sta $BFDF+1

; optimize FAIL ('PMGCLEAR', game.pas), line = 213

	jsr PMGCLEAR

; optimize OK (game.pas), line = 214

	lda OUTDINOX
	sta DINOX
	lda OUTDINOY
	sta DINOY

; optimize OK (game.pas), line = 216

	lda #$80
	sta DINOSTATE

; optimize OK (game.pas), line = 217

	lda #$00
	sta DINODX
	sta DINODY
l_066C
	jmp l_0698
l_0652

; optimize OK (game.pas), line = 221

	lda DINOSTATE
	and #$EF
	sta DINOSTATE
l_0698
l_0640
	jmp l_06AB
l_05CC

; optimize OK (game.pas), line = 226

	lda DINODY
	sub #$05
	svc
	eor #$80
	jpl l_06BD
	lda DINODY
	add #$02
	sta DINODY
l_06BD

; optimize OK (game.pas), line = 227

	lda DINOY
	add DINODY
	sta DINOY

; optimize OK (game.pas), line = 228

	cmp #$B7
	jcc l_06D6

; optimize OK (game.pas), line = 230

	lda #$03
	sta GAMESTATE
	lda #$80
	sta DINOSTATE

; optimize OK (game.pas), line = 231

	lda #$00
	sta DINOX
l_06D6
l_06AB

; optimize OK (game.pas), line = 235

	lda DINOX
	sub #$2E
	sta @SMALLINT.DIV.A
	lda #$00
	sbc #$00
	sta @SMALLINT.DIV.A+1
	lda #$04
	sta @SMALLINT.DIV.B
	lda #$00
	sta @SMALLINT.DIV.B+1
	jsr @SMALLINT.DIV
	lda :eax
	sta SX

; optimize OK (game.pas), line = 236

	lda DINOY
	sub #$3C
	sta @SMALLINT.DIV.A
	lda #$00
	sbc #$00
	sta @SMALLINT.DIV.A+1
	lda #$08
	sta @SMALLINT.DIV.B
	lda #$00
	sta @SMALLINT.DIV.B+1
	jsr @SMALLINT.DIV
	lda :eax
	sta SY

; optimize OK (game.pas), line = 237

	lda GAMESTATE
	cmp #$01
	jne l_0713

; optimize OK (game.pas), line = 239

	lda #$D0
	add SX
	sta :STACKORIGIN+9
	lda #$B8
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda SY
	jsr @mul40
	add :STACKORIGIN+9
	sta ADR
	lda :eax+1
	adc :STACKORIGIN+STACKWIDTH+9
	sta ADR+1

; optimize OK (game.pas), line = 240

	sta :bp+1
	ldy ADR
	lda (:bp),y
	sta CH1
	inc ADR
	sne
	inc ADR+1
	ldy ADR+1
	sty :bp+1
	ldy ADR
	lda (:bp),y
	sta CH2

; optimize OK (game.pas), line = 241

	ldy #1
	lda CH1
	cmp #$2A
	bcs @+
	dey
@
	sty :STACKORIGIN+9

	lda #$2D
	cmp CH1
	lda #$00
	rol @
	and :STACKORIGIN+9
	sta :STACKORIGIN+9
	ldy #1
	lda CH2
	cmp #$2A
	bcs @+
	dey
@
	sty :STACKORIGIN+10

	lda #$2D
	cmp CH2
	lda #$00
	rol @
	and :STACKORIGIN+10
	and :STACKORIGIN+9
	jeq l_0772

; optimize OK (game.pas), line = 244

	lda #$02
	sta GAMESTATE

; optimize OK (game.pas), line = 245

	lda #$F8
	sta $BFDF
	lda #$A8
	sta $BFDF+1

; optimize FAIL ('PMGCLEAR', game.pas), line = 246

	jsr PMGCLEAR

; optimize OK (game.pas), line = 247

	lda #$04
	sta :ecx
	sta :ztmp8
	lda DINODX
	sta :eax
	sta :ztmp10
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	bit :ztmp10
	bpl @+
	sub :ztmp8
@
	bit :ztmp8
	bpl @+
	sub :ztmp10
@
	sta :eax+1
	lda DINOX
	add :eax
	sta OUTDINOX
	lda #$06
	sta :ecx
	sta :ztmp8
	lda DINODY
	sta :eax
	sta :ztmp10
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	bit :ztmp10
	bpl @+
	sub :ztmp8
@
	bit :ztmp8
	bpl @+
	sub :ztmp10
@
	sta :eax+1
	lda DINOY
	add :eax
	sta OUTDINOY

; optimize OK (game.pas), line = 249

	lda #$44
	sta DINOY
	lda #$80
	sta DINOX

; optimize OK (game.pas), line = 250

	lda #$00
	sta DINODX
	lda #$04
	sta DINODY

; optimize OK (game.pas), line = 251

	lda #$11
	jsr PLAYSFX

; optimize OK (game.pas), line = 253

	lda DINOSTATE
	and #$79
	sta DINOSTATE

; optimize OK (game.pas), line = 254

	ora #$04
	add #$08
	sta DINOSTATE
l_0772
	jmp l_07D0
l_0713

; optimize OK (game.pas), line = 257

	lda GAMESTATE
	cmp #$02
	jne l_07E2

; optimize OK (game.pas), line = 259

	lda #$F8
	add SX
	sta :STACKORIGIN+9
	lda #$A8
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda SY
	jsr @mul40
	add :STACKORIGIN+9
	tay
	lda :eax+1
	adc :STACKORIGIN+STACKWIDTH+9
	sta ADR+1
	tya
	add #$28
	sta ADR
	scc
	inc ADR+1

; optimize OK (game.pas), line = 260

	ldy ADR+1
	sty :bp+1
	ldy ADR
	lda (:bp),y
	and #$7F
	sta CH1

; optimize FAIL (0, game.pas), line = 261

	inc ADR
	sne
	inc ADR+1
	ldy ADR+1
	sty :bp+1
	ldy ADR
	lda (:bp),y
	and #$7F
	sta CH2

; optimize OK (game.pas), line = 262

	lda CH1
	cmp #$42
	jcc l_082Bs
	lda #$44
	cmp CH1
	jcc l_082Bs
	lda:sne #$01
l_082Bs	lda #$00
	sta A1

; optimize OK (game.pas), line = 263

	lda CH2
	cmp #$42
	jcc l_0843s
	lda #$44
	cmp CH2
	jcc l_0843s
	lda:sne #$01
l_0843s	lda #$00
	sta A2

; optimize OK (game.pas), line = 264

	lda A1
	jne l_085B
	lda A2
	jne l_085B

; optimize OK (game.pas), line = 266

	lda DINOSTATE
	and #$7F
	ora #$08
	sta DINOSTATE
	jmp l_0873
l_085B

; optimize OK (game.pas), line = 270

	lda DINOSTATE
	and #$08
	jeq l_0889

; optimize OK (game.pas), line = 272

	lda DINOSTATE
	and #$06
	ora #$80
	sta DINOSTATE

; optimize OK (game.pas), line = 273

	lda DINOFRM
	and #$03
	sta DINOFRM
l_0889

; optimize OK (game.pas), line = 275

	lda #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda SY
	asl @
	rol :STACKORIGIN+STACKWIDTH+10
	asl @
	asl @
	add #$40
	sta DINOY
	lda #$00
	sta DINODY
l_0873
l_07E2
l_07D0
l_0528
l_0514
	.ENDM

; ------------------------------------------------------------

SPRBASE	= DATAORIGIN+$0055
SX	= DATAORIGIN+$0056
SY	= DATAORIGIN+$0057
ADR	= DATAORIGIN+$0058
CH1	= DATAORIGIN+$005A
CH2	= DATAORIGIN+$005B
CNSL	= DATAORIGIN+$005C
A1	= DATAORIGIN+$005D
A2	= DATAORIGIN+$005E

@VarData	= SPRBASE
@VarDataSize	= 10

@exit
.endl

.local	DINOCONTROL					; PROCEDURE

; optimize OK (game.pas), line = 284

	lda STICK
	and #$0F
	sta JOYDIR

; optimize OK (game.pas), line = 285

	ldy #1
	lda adr.STRIG
	beq @+
	dey
@
	tya
	sta JOYFIRE

; optimize OK (game.pas), line = 287

	lda GAMESTATE
	cmp #$01
	jne l_08E6

; optimize OK (game.pas), line = 289

	ldy JOYDIR
	lda adr.JOY2SPR,y
	cmp #$FF
	jeq l_08FC

; optimize OK (game.pas), line = 291

	lda DINOSTATE
	and #$79
	sta :STACKORIGIN+9
	lda adr.JOY2SPR,y
	ora :STACKORIGIN+9
	sta DINOSTATE

; optimize OK (game.pas), line = 292

	lda adr.JOY2DX,y
	sta DINODX

; optimize OK (game.pas), line = 293

	lda adr.JOY2DY,y
	sta DINODY
l_08FC
	jmp l_092D
l_08E6

; optimize OK (game.pas), line = 296

	lda GAMESTATE
	cmp #$02
	jne l_093F

; optimize OK (game.pas), line = 298

	lda DINOSTATE
	ldy #1
	and #$08
	beq @+
	dey
@
	tya
	and JOYFIRE
	jeq l_095C

; optimize OK (game.pas), line = 300

	lda #$F8
	sta DINODY

; optimize OK (game.pas), line = 301

	lda DINOSTATE
	and #$06
	ora #$10
	sta DINOSTATE

; optimize OK (game.pas), line = 302

	lda JOYFIRE
	sta OJOYFIRE

; optimize OK (game.pas), line = 303

	lda #$10
	jsr PLAYSFX
	jmp @exit
l_095C

; optimize OK (game.pas), line = 307

	ldy JOYDIR
	lda adr.JOY2SPR,y
	cmp #$FF
	jeq l_098E

; optimize OK (game.pas), line = 309

	lda DINOSTATE
	and #$08
	jne l_09A5

; optimize OK (game.pas), line = 310

	lda DINOSTATE
	and #$79
	sta :STACKORIGIN+9
	lda adr.JOY2SPR,y
	ora :STACKORIGIN+9
	sta DINOSTATE
l_09A5

; optimize OK (game.pas), line = 312

	ldy JOYDIR
	lda adr.JOY2DX,y
	sta DINODX
l_098E
l_093F
l_092D

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PTEROANIM					; PROCEDURE

; optimize OK (game.pas), line = 319

	lda adr.TIMER+$01
	jne l_09EB
	lda PTEROSTATE
	cmp #$FF
	jeq l_09EB

; optimize OK (game.pas), line = 321

	lda #$07
	sta adr.TIMER+$01

; optimize OK (game.pas), line = 322

	lda #$28
	sta :STACKORIGIN+9
	ldy #$00
	lda PTEROX
	spl
	dey
	add :STACKORIGIN+9
	sta PTEROADR
	tya
	adc #$B8
	sta PTEROADR+1

; optimize OK (game.pas), line = 323

	lda PTEROSTATE
	cmp #$01
	jne l_0A11

; optimize OK (game.pas), line = 325

	ldy PTEROADR+1
	sty :bp+1
	ldy PTEROADR
	lda #$E0
	sta (:bp),y
	inc PTEROADR
	sne
	inc PTEROADR+1

; optimize OK (game.pas), line = 326

	ldy PTEROADR+1
	sty :bp+1
	ldy PTEROADR
	lda #$E1
	sta (:bp),y
	inc PTEROADR
	sne
	inc PTEROADR+1

; optimize OK (game.pas), line = 327

	ldy PTEROADR+1
	sty :bp+1
	ldy PTEROADR
	lda #$E2
	sta (:bp),y
	inc PTEROADR
	sne
	inc PTEROADR+1

; optimize OK (game.pas), line = 328

	ldy PTEROADR+1
	sty :bp+1
	ldy PTEROADR
	lda #$E3
; optimize OK (game.pas), line = 329
	jmp l_0A3F
l_0A11

; optimize OK (game.pas), line = 333

	ldy PTEROADR+1
	sty :bp+1
	ldy PTEROADR
	lda #$E4
	sta (:bp),y
	inc PTEROADR
	sne
	inc PTEROADR+1

; optimize OK (game.pas), line = 334

	ldy PTEROADR+1
	sty :bp+1
	ldy PTEROADR
	lda #$E5
	sta (:bp),y
	inc PTEROADR
	sne
	inc PTEROADR+1

; optimize OK (game.pas), line = 335

	ldy PTEROADR+1
	sty :bp+1
	ldy PTEROADR
	lda #$E6
	sta (:bp),y
	inc PTEROADR
	sne
	inc PTEROADR+1

; optimize OK (game.pas), line = 336

	ldy PTEROADR+1
	sty :bp+1
	ldy PTEROADR
	lda #$E7
l_0A3F
	sta (:bp),y
	inc PTEROADR
	sne
	inc PTEROADR+1

; optimize OK (game.pas), line = 337

	ldy PTEROADR+1
	sty :bp+1
	ldy PTEROADR
	lda #$00
	sta (:bp),y

; optimize OK (game.pas), line = 339

	inc PTEROSTATE
	lda PTEROSTATE
	cmp #$04
	jne l_0A76
	lda #$01
	sta PTEROSTATE
l_0A76

; optimize OK (game.pas), line = 340

	lda PTEROX
	jmi l_0A8F
	jeq l_0A8F

; optimize FAIL (0, game.pas), line = 341

	dec PTEROX
	jmp l_0A9D
l_0A8F

; optimize OK (game.pas), line = 344

	ldy PTEROADR+1
	sty :bp+1
	ldy PTEROADR
	lda #$00
	sta (:bp),y
	inc PTEROADR
	sne
	inc PTEROADR+1

; optimize OK (game.pas), line = 345

	ldy PTEROADR+1
	sty :bp+1
	ldy PTEROADR
	sta (:bp),y
	inc PTEROADR
	sne
	inc PTEROADR+1

; optimize OK (game.pas), line = 346

	ldy PTEROADR+1
	sty :bp+1
	ldy PTEROADR
	sta (:bp),y
	inc PTEROADR
	sne
	inc PTEROADR+1

; optimize OK (game.pas), line = 347

	ldy PTEROADR+1
	sty :bp+1
	ldy PTEROADR
	sta (:bp),y

; optimize OK (game.pas), line = 348

	lda #$FF
	sta PTEROSTATE

; optimize FAIL (2, game.pas), line = 349

	inx
	mva #$02 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$19 :STACKORIGIN,x
	lda #$32
	jsr SYSTEM.RANDOM.@010180000
	lda :STACKORIGIN,x
	add SYSTEM.RANDOM.@010180000.RESULT
	ldy :STACKORIGIN-1,x
	sta adr.TIMER,y
	dex
	dex
l_0A9D
l_09EB

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PTEROCONTROL					; PROCEDURE

; optimize OK (game.pas), line = 359

	lda PTEROSTATE
	cmp #$FF
	jne l_0ADF

; optimize OK (game.pas), line = 361

	lda adr.TIMER+$02
	jne l_0AF3

; optimize OK (game.pas), line = 363

	sta PTEROSTATE

; optimize OK (game.pas), line = 364

	lda #$28
	sta PTEROX

; optimize OK (game.pas), line = 365

	lda GAMESTATE
	cmp #$01
	jne l_0B0E

; optimize OK (game.pas), line = 367

	lda #$19
	jsr SYSTEM.RANDOM.@010180000
	lda SYSTEM.RANDOM.@010180000.RESULT
	sta A

; optimize OK (game.pas), line = 368

	asl @
	asl @
	sta adr.TIMER+$03

; optimize FAIL (1, game.pas), line = 369

	inx
	mva #$0F :STACKORIGIN,x
	lda #$14
	jsr SYSTEM.RANDOM.@010180000
	lda :STACKORIGIN,x
	add SYSTEM.RANDOM.@010180000.RESULT
	sta STONEDST
	dex

; optimize OK (game.pas), line = 370

	lda #$00
	jmp l_0B35
l_0B0E

; optimize OK (game.pas), line = 374

	lda #$FF
l_0B35
	sta STONESTATE
l_0AF3
l_0ADF

; ------------------------------------------------------------

A	= DATAORIGIN+$005F

@VarData	= A
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	STONECONTROL					; PROCEDURE

; optimize OK (game.pas), line = 382

	lda STONESTATE
	cmp #$FF
	jeq @exit
l_0B53

; optimize OK (game.pas), line = 383

	lda adr.TIMER+$03
	jeq l_0B69
	jmp @exit
l_0B69

; optimize OK (game.pas), line = 385

	lda STONESTATE
	jne l_0B7E

; optimize OK (game.pas), line = 387

	lda #$04
	sta :ecx
	sta :ztmp8
	lda PTEROX
	sta :eax
	sta :ztmp10
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	bit :ztmp10
	bpl @+
	sub :ztmp8
@
	bit :ztmp8
	bpl @+
	sub :ztmp10
@
	sta :eax+1
	lda #$28
	add :eax
	sta STONEX

; optimize OK (game.pas), line = 388

	lda #$28
	sta STONEY

; optimize OK (game.pas), line = 389

	lda #$01
	sta STONESTATE

; optimize OK (game.pas), line = 390

	lda #$15
	jsr PLAYSFX
	jmp l_0BA0
l_0B7E

; optimize FAIL (0, game.pas), line = 394

	dec STONEDST

; optimize OK (game.pas), line = 395

	jne l_0BB6

; optimize OK (game.pas), line = 397

	lda #$FF
	sta STONESTATE

; optimize OK (game.pas), line = 398

	lda #$54
	sta :STACKORIGIN+9
	lda #$B8
	sta :STACKORIGIN+STACKWIDTH+9
	lda STONEY
	sub #$24
	sta @SMALLINT.DIV.A
	lda #$00
	sbc #$00
	sta @SMALLINT.DIV.A+1
	lda #$08
	sta @SMALLINT.DIV.B
	lda #$00
	sta @SMALLINT.DIV.B+1
	jsr @SMALLINT.DIV
	lda #$28
	sta :ecx
	lda #$00
	sta :ecx+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda :eax
	add :STACKORIGIN+9
	sta :STACKORIGIN+9
	lda :eax+1
	adc :STACKORIGIN+STACKWIDTH+9
	sta :STACKORIGIN+STACKWIDTH+9
	lda STONEX
	sub #$1C
	sta @SMALLINT.DIV.A
	lda #$00
	sbc #$00
	sta @SMALLINT.DIV.A+1
	lda #$04
	sta @SMALLINT.DIV.B
	lda #$00
	sta @SMALLINT.DIV.B+1
	jsr @SMALLINT.DIV
	lda :eax
	add :STACKORIGIN+9
	sta STONEADR
	lda :eax+1
	adc :STACKORIGIN+STACKWIDTH+9
	sta STONEADR+1

; optimize OK (game.pas), line = 399

	lda STONEADR
	sub #$02
	sta STONEADR
	scs
	dec STONEADR+1

; optimize OK (game.pas), line = 400

	ldy STONEADR+1
	sty :bp+1
	ldy STONEADR
	lda #$2A
	sta (:bp),y
	inc STONEADR
	sne
	inc STONEADR+1

; optimize OK (game.pas), line = 401

	ldy STONEADR+1
	sty :bp+1
	ldy STONEADR
	lda #$2B
	sta (:bp),y
	inc STONEADR
	sne
	inc STONEADR+1

; optimize OK (game.pas), line = 402

	ldy STONEADR+1
	sty :bp+1
	ldy STONEADR
	lda #$2C
	sta (:bp),y
	inc STONEADR
	sne
	inc STONEADR+1

; optimize OK (game.pas), line = 403

	ldy STONEADR+1
	sty :bp+1
	ldy STONEADR
	lda #$2D
	sta (:bp),y

; optimize OK (game.pas), line = 404

	lda #$00
	sta STONEX
	lda #$FF
	sta STONEY

; optimize OK (game.pas), line = 405

	lda #$12
	jsr PLAYSFX
	jmp @exit
l_0BB6

; optimize OK (game.pas), line = 409

	lda STONEADR
	sta OSTONEADR
	lda STONEADR+1
	sta OSTONEADR+1

; optimize OK (game.pas), line = 411

	lda #$01
	sub STONEFRM
	sta STONEFRM

; optimize OK (game.pas), line = 412

	lda #$01
	add STONEFRM
	sta STONESTATE

; optimize OK (game.pas), line = 414

	lda STONEX
	sub #$02
	sta STONEX

; optimize OK (game.pas), line = 415

	lda STONEY
	add #$04
	sta STONEY

; optimize OK (game.pas), line = 417

	lda #$04
	sta adr.TIMER+$03
l_0BA0

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	OVER_INIT					; PROCEDURE

; optimize OK (game.pas), line = 426

	lda #$FF
	sta KEYB

; optimize FAIL ('PMGCLEAR', game.pas), line = 427

	jsr PMGCLEAR

; optimize OK (game.pas), line = 429

	lda #$80
	sta $BFF1
	lda #$A8
	sta $BFF1+1

; optimize OK (game.pas), line = 431

	lda #$00
	sta I

l_0C4A
; --- ForToDoCondition
	lda I
	cmp #$C8
	jcs l_0C58

; optimize FAIL ('WAIT4SCREEN', game.pas), line = 432

	jsr WAIT4SCREEN
	inc I
	jne l_0C4A
l_0C58

; ------------------------------------------------------------

I	= DATAORIGIN+$0060

@VarData	= I
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	GAME_LOOP					; PROCEDURE

; optimize OK (game.pas), line = 439

	lda #$0C
	sta RMT.TRMT.INIT.A
	lda MSX
	ldy MSX+1
	jsr RMT.TRMT.INIT

; --- RepeatUntilProlog
l_0C65

; optimize FAIL ('m@INLINE', game.pas), line = 441

	.LOCAL +MAIN.DINOANIM
	m@INLINE
	.ENDL

; optimize FAIL ('PTEROANIM', game.pas), line = 442

	jsr PTEROANIM

; optimize FAIL ('DINOCONTROL', game.pas), line = 443

	jsr DINOCONTROL

; optimize FAIL ('PTEROCONTROL', game.pas), line = 444

	jsr PTEROCONTROL

; optimize FAIL ('STONECONTROL', game.pas), line = 445

	jsr STONECONTROL

; optimize OK (game.pas), line = 446

	lda KEYB
	cmp #$FF
	jeq l_0C7C
	lda #$03
	sta GAMESTATE
l_0C7C

; optimize OK (game.pas), line = 447

	lda GAMESTATE
	cmp #$03
	jne l_0C65

; optimize FAIL ('OVER_INIT', game.pas), line = 449

	jsr OVER_INIT

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
l_0004

; optimize OK (main.pas), line = 60

	lda #$00
	sta MSX.PLAYER
	lda #$8C
	sta MSX.PLAYER+1

; optimize OK (main.pas), line = 61

	lda #$00
	sta MSX.MODUL
	lda #$C0
	sta MSX.MODUL+1

; --- RepeatUntilProlog
l_0C9B

; optimize FAIL ('INIT_TITLE', main.pas), line = 65

	jsr INIT_TITLE

; optimize FAIL ('TITLE_LOOP', main.pas), line = 66

	jsr TITLE_LOOP

; optimize FAIL ('INIT_GAME', main.pas), line = 68

	jsr INIT_GAME

; optimize FAIL ('GAME_LOOP', main.pas), line = 69

	jsr GAME_LOOP

; optimize OK (main.pas), line = 71

	jmp l_0C9B

; ------------------------------------------------------------

FNT_TITLE	= $9000
SCR_TITLE	= $9800
RMT_PLAYER	= $8C00
FNT_STATUS	= $A400
STATUS_ADDR	= $A800
GOVER_ADDR	= $A880
CRATER_ADDR	= $A8F8
FNT_GAME	= $AC00
PMG_ADDR	= $B000
SPR_ADDR	= $B000
SCREEN_ADDR	= $B800
DL_TITLE	= $BF90
DL_GAME	= $BFD0
RMT_MODUL	= $C000
PTR1	= $50
PTR2	= $52
PTR3	= $54
adr.MSX	= DATAORIGIN+$0029	; [4] OBJECT
.var MSX	= adr.MSX .word
MSX.PLAYER	= DATAORIGIN+$0029
MSX.MODUL	= DATAORIGIN+$002B
VDSLST	= $0200
DL	= $0230
STICK	= $D300
adr.STRIG	= $D010
.var STRIG	= adr.STRIG .word
adr.FCOL	= $02C4
.var FCOL	= adr.FCOL .word
KEYB	= $02FC
CHBAS	= $02F4
COLPF0	= $D016
COLPF1	= $D017
COLPF2	= $D018
COLPF3	= $D019
COLBK	= $D01A
RAND	= $D20A
IRQST	= $D40E
CHBASE	= $D409
WSYNC	= $D40A
adr.TIMER	= $D4
.var TIMER	= adr.TIMER .word
GAMESTATE	= DATAORIGIN+$002D
adr.DINOP0	= CODEORIGIN+$0000
.var DINOP0	= adr.DINOP0 .word
adr.DINOP1	= CODEORIGIN+$0014
.var DINOP1	= adr.DINOP1 .word
adr.STONEP2	= CODEORIGIN+$0028
.var STONEP2	= adr.STONEP2 .word
adr.PCOLR	= $02C0
.var PCOLR	= adr.PCOLR .word
SDMCTL	= $022F
GPRIO	= $026F
adr.SIZEP	= $D008
.var SIZEP	= adr.SIZEP .word
adr.HPOSP	= $D000
.var HPOSP	= adr.HPOSP .word
adr.HPOSM	= $D004
.var HPOSM	= adr.HPOSM .word
SIZEM	= $D00C
PMBASE	= $D407
PMCNTL	= $D01D
adr._PL0	= $B400
.var _PL0	= adr._PL0 .word
adr._PL1	= $B500
.var _PL1	= adr._PL1 .word
adr._PL2	= $B600
.var _PL2	= adr._PL2 .word
DINOX	= $56
DINOY	= $57
DINODX	= DATAORIGIN+$0034
DINODY	= DATAORIGIN+$0035
ODINOY	= DATAORIGIN+$0036
DINOFRM	= DATAORIGIN+$0037
ODINOFRM	= DATAORIGIN+$0038
OUTDINOX	= DATAORIGIN+$0039
OUTDINOY	= DATAORIGIN+$003A
STONEX	= DATAORIGIN+$003B
STONEY	= DATAORIGIN+$003C
STONEDX	= DATAORIGIN+$003D
STONEDY	= DATAORIGIN+$003E
OSTONEY	= DATAORIGIN+$003F
STONEFRM	= DATAORIGIN+$0040
OSTONEFRM	= DATAORIGIN+$0041
DSNONE	= $80
DSWALKLEFT	= $00
DSWALKRIGHT	= $02
DSWALKUP	= $04
DSWALKDOWN	= $06
DSWALK	= $06
DSFALL	= $08
DSJUMP	= $10
TMDINOANIM	= $00
TMPTEROANIM	= $01
TMPTERODLY	= $02
TMPTEROSHT	= $03
SFXDINOSTEP	= $14
SFXDINOFALL	= $11
SFXDINOJUMP	= $10
SFXPTERODROP	= $15
SFXSTONEHIT	= $12
adr.JOY2SPR	= CODEORIGIN+$002C
.var JOY2SPR	= adr.JOY2SPR .word
adr.JOY2DX	= CODEORIGIN+$003C
.var JOY2DX	= adr.JOY2DX .word
adr.JOY2DY	= CODEORIGIN+$004C
.var JOY2DY	= adr.JOY2DY .word
DINOSTATE	= DATAORIGIN+$0046
DINOLASTDIR	= DATAORIGIN+$0047
JOYDIR	= DATAORIGIN+$0048
JOYFIRE	= DATAORIGIN+$0049
OJOYFIRE	= DATAORIGIN+$004A
PTEROSTATE	= DATAORIGIN+$004B
PTEROADR	= DATAORIGIN+$004C
PTEROX	= DATAORIGIN+$004E
STONESTATE	= DATAORIGIN+$004F
STONEADR	= DATAORIGIN+$0050
OSTONEADR	= DATAORIGIN+$0052
STONEDST	= DATAORIGIN+$0054
@exit

@halt	ldx #$00
	txs

	.ifdef MAIN.@DEFINES.ROMOFF
	inc portb
	.fi

	ldy #$01

	rts

; ------------------------------------------------------------

.local	@DEFINES
ATARI
CPU_6502
BASICOFF
ROMOFF
NOROMFONT
.endl

.local	@RESOURCE
.endl

.endl							; MAIN

; ------------------------------------------------------------
; ------------------------------------------------------------

.macro	UNITINITIALIZATION

	.ifdef MAIN.SYSTEM.@UnitInit
	jsr MAIN.SYSTEM.@UnitInit
	.fi

	.ifdef MAIN.ATARI.@UnitInit
	jsr MAIN.ATARI.@UnitInit
	.fi

	.ifdef MAIN.MISC.@UnitInit
	jsr MAIN.MISC.@UnitInit
	.fi

	.ifdef MAIN.RMT.@UnitInit
	jsr MAIN.RMT.@UnitInit
	.fi
.endm

; ------------------------------------------------------------

	ift .SIZEOF(MAIN.SYSTEM) > 0
	.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.ATARI) > 0
	.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
	eif

	ift .SIZEOF(MAIN.MISC) > 0
	.print 'MISC: ',MAIN.MISC,'..',MAIN.MISC+.SIZEOF(MAIN.MISC)-1
	eif

	ift .SIZEOF(MAIN.RMT) > 0
	.print 'RMT: ',MAIN.RMT,'..',MAIN.RMT+.SIZEOF(MAIN.RMT)-1
	eif

.nowarn	.print 'CODE: ',CODEORIGIN,'..',MAIN.@RESOURCE-1

	ift .SIZEOF(MAIN.@RESOURCE)>0
.nowarn	.print 'RESOURCE: ',MAIN.@RESOURCE,'..',MAIN.@RESOURCE+.SIZEOF(MAIN.@RESOURCE)-1
	eif

@end

.nowarn	.print 'VARS: ',MAIN.@RESOURCE+.SIZEOF(MAIN.@RESOURCE),'..',@end-1

; ------------------------------------------------------------

	?adr = *
	ift (?adr < ?old_adr) && (?old_adr - ?adr < $120)
	?adr = ?old_adr
	eif

	org ?adr
	?old_adr = *

DATAORIGIN
.by  $2D $0C $00 $00 $00 $28 $00 $18

VARINITSIZE	= *-DATAORIGIN
VARDATASIZE	= 97

PROGRAMSTACK	= DATAORIGIN+VARDATASIZE

	.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK

	ert DATAORIGIN<@end,'DATA memory overlap'

	run START

; ------------------------------------------------------------

.macro	STATICDATA
.by  $00 $B0 $10 $B0 $20 $B0 $30 $B0  $40 $B0 $50 $B0 $60 $B0 $70 $B0  $80 $B0 $90 $B0 $A0 $B0 $B0 $B0
.by  $C0 $B0 $D0 $B0 $E0 $B0 $F0 $B0  $00 $B1 $10 $B1 $20 $B1 $30 $B1  $40 $B1 $50 $B1 $FF $FF $FF $FF
.by  $FF $FF $FF $00 $FF $FF $FF $02  $FF $06 $04 $FF $00 $00 $00 $00  $00 $00 $00 $02 $00 $00 $00 $FE
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $04 $FC $00
.endm

	end
